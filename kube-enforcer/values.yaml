global:
  #Please specify k8s platform acronym. Allowed values are aks, eks, gke, openshift, tkg, tkgi, k8s
  # aks = Azure Kubernetes Service
  # gke = Google kubernetes Engine
  # openshift = RedHat Openshift/OCP
  # tkg = VMware Tanzu kubernetes Grid
  # tkgi = VMware Tanzu kubernetes Grid Integrated Edition
  # k8s = Plain/on-prem Vanilla Kubernetes
  # rancher = Rancher Kubernetes Platform
  # gs = GaintSwarm platform
  # k3s = k3s kubernetes platform
  # mke = Mirantis Kubernetes Engine
  platform: ""
  enforcer:
    enabled: false
  gateway:
    # change address to gateway endpoint
    address: aqua-gateway-svc.aqua
    port: 8443
  # Specifies the secret data for imagePullSecrets needed to fetch the private docker images
  imageCredentials:
    # If imageCredentials.create=false and imageCredentials.name not defined
    # then will be used secret aqua-registry-secret which created by aqua-server helm chart
    #####################
    # If imageCredentials.create=false and imageCredentials.name defined then will be used secret with defined name
    # but in this case secret should be created manually before chart deploying
    #####################
    # If imageCredentials.create=create and imageCredentials.name not defined
    # then will be created a secret with name <Chart ReleaseName>-registry-secret
    #####################
    # If imageCredentials.create=create and imageCredentials.name defined
    # then will be created a secret with name provided name
    create: false
    name: "aqua-registry"
    repositoryUriPrefix: "registry.aquasec.com" # for dockerhub - "docker.io"
    registry: "registry.aquasec.com" #REQUIRED only if create is true, for dockerhub - "index.docker.io/v1/"
    username: ""
    password: ""

# If serviceAccount.create=false and serviceAccount.name not defined
# then will be used serviceAccount aqua-sa which created by aqua-server helm chart
#####################
# If serviceAccount.create=false and serviceAccount.name defined then will be used serviceAccount with defined name
# but in this case serviceAccount should be created manually before chart deploying
#####################
# If serviceAccount.create=create and serviceAccount.name not defined
# then will be created a serviceAccount with name <Chart ReleaseName>-sa
#####################
# If serviceAccount.create=create and serviceAccount.name defined
# then will be created a serviceAccount with name provided name
serviceAccount:
  create: false
  name: ""

# Specify whether to enable/disable the cache by using "yes", "true", "no", "false" values.
aqua_enable_cache: "yes"
# default value is 60
aqua_cache_expiration_period: "60"

image:
  repository: "kube-enforcer"
  tag: "2022.4"
  pullPolicy: Always

ke_ReplicaCount: "1"

nameOverride: "aqua-kube-enforcer"
fullnameOverride: "aqua-kube-enforcer"

# Display a custom cluster name in the infrastructure tab of Aqua Enterprise
clusterName: "Default-cluster-name"
logicalName: ""
logLevel: ""

# Set create to false if you want to use an existing secret for the kube-enforcer certs
# If certsSecret.create and certsSecret.name defined then need provide certsSecret.serverCertificate and
# certsSecret.serverKey and webhooks.caBundle encrypted with base64 and secret for TLS connectivity with kube-api will be created
# If you want to use auto generated self-signed certificates use option certsSecret.autoGenerated=true and all required self-signed
# certificates will be created and added to secret with name certsSecret.name
# Please be aware that if you already has TLS secret created in cluster and decided to use option certsSecret.autoGenerate
# It will fail with following error. To solve it delete previously create secret kubectl delete secret aqua-kube-enforcer-certs -n aqua
# Error: UPGRADE FAILED: error validating "": error validating data: unknown object type "nil" in Secret.data.ca.crt
certsSecret:
  autoGenerate: false
  create: true
  # If you're using existing certs change the name to existing secret name
  name: "aqua-kube-enforcer-certs"
  serverCertificate: ""
  serverKey: ""

aquaSecret:
  create: true
  name: "aqua-kube-enforcer-token"
  # Enter the enforcer token in "clear-text" format without quotes generated from the Console UI
  kubeEnforcerToken: ke-token

clusterRole:
  name: "aqua-kube-enforcer"

clusterRoleBinding:
  name: "aqua-kube-enforcer"

role:
  name: "aqua-kube-enforcer"

roleBinding:
  name: "aqua-kube-enforcer"

webhooks:
  # set this field true if you're using cert-manager and don't need to pass a caBundle
  certManager: false
  # Add base64 value of the CA cert/Ca Bundle/RootCA Cert if certificates are not generated from cert-manager to webhooks.caBundle
  caBundle: ""
  failurePolicy: Ignore
  validatingWebhook:
    name: "kube-enforcer-admission-hook-config"
    annotations: {}
  mutatingWebhook:
    name: "kube-enforcer-me-injection-hook-config"
    annotations: {}
      #cert-manager.io/inject-ca-from: < namespace >/< certsSecret.name >
      #If you are using webhooks.certManager=true, so need to add cert-manager annotations

securityContext:
  runAsUser: 11431
  runAsGroup: 11433
  fsGroup: 11433

container_securityContext: {}

readinessProbe:
  httpGet:
    path: /readyz
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 30

livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 30

## Please use the below probes for KubeEnforcer version < 6.5.22052 or version != latest
## livenessProbe:
##   httpGet:
##   tcpSocket:
##     port: 8080
##   initialDelaySeconds: 60
##   periodSeconds: 30
##
## readinessProbe:
##   httpGet:
##   tcpSocket:
##     port: 8080
##   initialDelaySeconds: 60
##   periodSeconds: 30

resources: {}
  # Note: For recommendations please check the official sizing guide.
  # requests:
  #   cpu: 250m
  #   memory: 0.2Gi
  # limits:
  #   cpu: 500m
  #   memory: 1.5Gi

nodeSelector: {}
tolerations: []
podAnnotations: {}
podLabels: {}
affinity: {}

TLS:
  # enable to true for secure communication
  enabled: false
  # provide certificates secret name created to enable tls/mtls communication between enforcer and gateway/envoy
  secretName: ""
  # provide filename of the public key eg: aqua_web.crt
  publicKey_fileName: ""
  # provide filename of the private key eg: aqua_web.key
  privateKey_fileName: ""
  # provide filename of the rootCA, if using self-signed certificates eg: rootCA.crt
  rootCA_fileName: ""
  # change it to true for enabling mTLS between enforcer and gateway/envoy
  tls_verify: false

# extraEnvironmentVars is a list of extra environment variables to set in the kube-enforcer deployment
# https://docs.aquasec.com/docs/kubeenforcer-variables
# The variables could be provided via values.yaml file as shown below
# or using cli command, for example:  --set extraEnvironmentVars.http_proxy="1.1.1.1",extraEnvironmentVars.https_proxy="2.2.2.2"
extraEnvironmentVars: {}
  # http_proxy: < >
  # https_proxy: < >
  # no_proxy: < >
  # ENV_NAME: value

# extraSecretEnvironmentVars is a list of extra environment variables to set in the enforcer daemonset.
# These variables take value from existing Secret objects.
extraSecretEnvironmentVars: []
  # - envName: ENV_NAME
  #   secretName: name
  #   secretKey: key

starboard:
  replicaCount: "1"
  appName: "starboard-operator"
  serviceAccount:
    create: true
    name: "starboard-operator"
  clusterRoleBinding:
    name: "starboard-operator"
  clusterRole:
    name: "starboard-operator"
  automountServiceAccountToken: "true"

  securityContext: {}

  image:
    repositoryUriPrefix: "docker.io/aquasec"
    repository: "starboard-operator"
    tag: "0.14.1"
    pullPolicy: Always

  container_securityContext:
    privileged: false
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    capabilities:
      drop:
        - ALL

  OPERATOR_NAMESPACE: "aqua"
  OPERATOR_TARGET_NAMESPACES: ""
  OPERATOR_LOG_DEV_MODE: "false"
  OPERATOR_CONCURRENT_SCAN_JOBS_LIMIT: "10"
  OPERATOR_SCAN_JOB_RETRY_AFTER: "30s"
  OPERATOR_METRICS_BIND_ADDRESS: ":8080"
  OPERATOR_HEALTH_PROBE_BIND_ADDRESS: ":9090"
  OPERATOR_CIS_KUBERNETES_BENCHMARK_ENABLED: "false"
  OPERATOR_VULNERABILITY_SCANNER_ENABLED: "false"
  OPERATOR_BATCH_DELETE_LIMIT: "10"
  OPERATOR_BATCH_DELETE_DELAY: "10s"

  conftest_resources_requests_cpu: "1m"
  conftest_resources_requests_memory: "10M"
  conftest_resources_limits_cpu: "15m"
  conftest_resources_limits_memory: "40M"

  ports:
    metricContainerPort: 8080
    probeCntainerPort: 9090

  readinessProbe:
    httpGet:
      path: /readyz/
      port: probes
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    failureThreshold: 3

  livenessProbe:
    httpGet:
      path: /healthz/
      port: probes
    initialDelaySeconds: 5
    periodSeconds: 10
    successThreshold: 1
    failureThreshold: 10

  nodeSelector: {}
  tolerations: [ ]
  podAnnotations: { }
  affinity: { }

##Kube Enforcer advance deployment options
### Advanced Deployment (for Pod Enforcer injection)
### When using KubeEnforcers for Pod Enforcer injection, it is recommended that you deploy the KubeEnforcers in a special Advanced configuration.
### This will cause Pod Enforcer traffic to be routed to the KubeEnforcers via a local envoy, which then forwards the traffic to an Aqua Gateway.
### This configuration improves performance and reduces remote network connections between pods and Gateways.
kubeEnforcerAdvance:
  enable: false
  nodeID: "envoy"

  envoy:
    image:
      repository: "envoy"
      tag: "2022.4"
      pullPolicy: Always

    # Enabling Envoy requires the use of TLS certificates for the cluster section, while the cluster TLS section is optional and to be enabled if TLS is in use for kube-enforcer and gateway.
    # Find the instructions in the readme for help with generating the required certificates.
    TLS:
      listener:
        # true to enable secure communication between Aqua Envoy and Gateways
        enabled: false
        # provide secret name containing the certificates
        secretName: "envoy-mtls-certs"
        # provide filename of the public key in the secret eg: aqua-lb.crt
        publicKey_fileName: ""
        # provide filename of the private key in the secret eg: aqua-lb.key
        privateKey_fileName: ""
        # optional: use this field if using a custom CA or chain
        rootCA_fileName: ""

    readinessProbe:
      exec:
        command:
        - cat
        - /etc/aquasec/envoy/configured
      initialDelaySeconds: 30
      periodSeconds: 10

    livenessProbe: {}

    resources: {}

    ## Enabling this will replace any templated envoy configuration with the list of files passed below
    custom_envoy_files: {}

enforcer:
  serviceAccount:
    create: true
    name: ""

  clusterRole:
    roleRef: ""

  # Enter the enforcer token in "clear-text" format without quotes generated from the Console UI
  enforcerToken: enforcer-token
  expressMode: false
  enforcerTokenSecretName: null
  enforcerTokenSecretKey: null

  logicalName:
  nodeName:

  securityContext:
    privileged: false
    capabilities:
      add:
        - SYS_ADMIN
        - NET_ADMIN
        - NET_RAW
        - SYS_PTRACE
        - KILL
        - MKNOD
        - SETGID
        - SETUID
        - SYS_MODULE
        - AUDIT_CONTROL
        - SYSLOG
        - SYS_CHROOT
        - SYS_RESOURCE
        - IPC_LOCK

  hostRunPath: # pks - /var/vcap/sys/run/docker
  # enable this to connect enforcer with multiple gateways
  multiple_gateway:
    enabled: false
  # use the below hosts to add multiple gateways as required to enforcer. Format is <hostname>:<port_number>
  multi_gates:
    - aqua-gateway1-svc:8443 #example gateway 1
    - aqua-gateway2-svc:8443 #example gateway 2


  image:
    repository: enforcer
    tag: "2022.4"
    pullPolicy: Always

  restartPolicy: Always

  healthMonitor:
    enabled: "true"

  livenessProbe:
    httpGet:
      path: /healthz
      port: 8096
    initialDelaySeconds: 60
    periodSeconds: 30
  readinessProbe:
    httpGet:
      path: /readinessz
      port: 8096
    initialDelaySeconds: 60
    periodSeconds: 30
  resources: { }
    # Note: For recommendations please check the official sizing guide.
    # requests:
    #   cpu: 350m
    #   memory: 0.512Gi
    # limits:
  #   cpu: 1500m
  #   memory: 1.5Gi
  nodeSelector: { }
  tolerations: [ ]
  podAnnotations: { }
  affinity: { }
  #  my-annotation-key: my value; more value
  podLabels: {}

  dnsPolicy: "ClusterFirst"
  hostPID: "true"
  schedulerName: "default-scheduler"
  terminationGracePeriodSeconds: "30"

  TLS:
    enabled: false
    # provide certificates secret name created to enable tls/mtls communication between enforcer and gateway/envoy
    secretName: ""
    #provide filename of the public key eg: aqua_enforcer.crt
    publicKey_fileName: ""
    #provide filename of the private key eg: aqua_enforcer.key
    privateKey_fileName: ""
    #provide filename of the rootCA, if using self-signed certificates eg: rootCA.crt
    rootCA_fileName: ""
    # change it to true for enabling mTLS between enforcer and gateway/envoy
    tls_verify: false

  # extraEnvironmentVars is a list of extra environment variables to set in the enforcer daemonset.
  # https://docs.aquasec.com/docs/enforcer-optional-variables
  # The variables could be provided via values.yaml file as shown below
  # or using cli command, for example:  --set extraEnvironmentVars.http_proxy="1.1.1.1",extraEnvironmentVars.https_proxy="2.2.2.2"
  extraEnvironmentVars: { }
    # http_proxy: < >
    # https_proxy: < >
    # no_proxy: < >
    # ENV_NAME: value

  # extraSecretEnvironmentVars is a list of extra environment variables to set in the enforcer daemonset.
  # These variables take value from existing Secret objects.
  extraSecretEnvironmentVars: [ ]
    # - envName: ENV_NAME
    #   secretName: name
    #   secretKey: key

